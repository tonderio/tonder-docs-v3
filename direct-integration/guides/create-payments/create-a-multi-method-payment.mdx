---
title: "Create a Multi-Method Payment"
sidebarTitle: "Multi-Method Payment"
'og:description': "How to implement fallback payment methods"
---

Multi-method payments allow you to offer customers alternative payment options when their preferred method fails. For example, if a customer's credit card is declined, you can automatically offer them a SPEI bank transfer or OXXO voucher as backup options.

This guide shows you how to implement a fallback payment system that tries multiple payment methods sequentially until one succeeds.

## Prerequisites

Before implementing multi-method payments, ensure you have:

- Valid Tonder API credentials with access to desired payment methods
- [Webhook setup](/direct-integration/webhooks/how-webhooks-works) for asynchronous payment status updates

## Understanding Multi-Method Flow

The fallback logic works by creating a prioritized list of payment methods and attempting each one until a transaction succeeds:

```mermaid
flowchart TD
    A[Start Payment Process] --> B[Try Primary Method]
    B --> C[Call Tonder API]
    C --> D{Payment Status?}
    D -->|Success/Pending| E[✅ Payment Initiated]
    D -->|Failed/Declined| F{More Methods?}
    F -->|Yes| G[Try Next Method]
    F -->|No| H[❌ All Methods Failed]
    G --> C
    E --> I[Handle Success Response]
    H --> J[Show Error to User]
```

<Warning>
**User Experience First**

Always inform users about fallback attempts. Ask for permission before switching to alternative methods rather than automatically redirecting to methods they didn't choose.
</Warning>

## Step 1: Define Your Fallback Strategy

Plan your payment method priority order. A typical fallback sequence might be:

1. Card: The most common and immediate method
2. SPEI: A reliable alternative, especially for larger amounts  
3. OXXO: A final fallback for users who may not have a bank account or card

Your server-side logic controls this flow. The Tonder API processes each request as a standalone transaction.

<Info>
**Implementation Flexibility**

The fallback logic shown in this guide is just one example approach. You're free to implement your own custom strategy based on your business needs, such as:

- Different priority orders for different customer segments
- Conditional fallbacks based on transaction amount
- Geographic or regulatory considerations
- User preference-driven fallback selection
</Info>

## Step 2: Implement the Fallback Loop

Create a function that tries each payment method sequentially until one succeeds:

```python
import uuid

# Assume 'tonder_api' is an initialized client for making API calls
# class TonderAPI:
#     def process_payment(self, payment_data):
#         # ... logic to make a POST request to /process/
#         # ... returns the JSON response as a dict

def process_payment_with_fallback(customer_data, amount, preferred_method="CARD"):
    """
    Attempts to process a payment using a preferred method, with fallbacks.
    
    Args:
        customer_data (dict): The customer's details (name, email).
        amount (float): The payment amount.
        preferred_method (str): The initial payment method to try.
    
    Returns:
        dict: The successful transaction response from the Tonder API.
    
    Raises:
        Exception: If all payment methods fail.
    """
    
    # Define the prioritized list of payment methods
    payment_methods_priority = [
        preferred_method,
        "CARD",  # Fallback to card if it wasn't the preferred method
        "SPEI",  # Next, try a bank transfer
        "OXXO"   # Final fallback is a cash payment
    ]
    
    # Use a set to avoid duplicate attempts (e.g., if preferred_method is 'CARD')
    unique_methods = list(dict.fromkeys(payment_methods_priority))
    
    for method in unique_methods:
        print(f"Attempting payment with method: {method}")
        try:
            # Construct the payment request body
            payment_data = {
                "operation_type": "payment",
                "amount": amount,
                "currency": "MXN",
                "customer": customer_data,
                "payment_method": {"type": method},
                "client_reference": f"order-{uuid.uuid4()}"
            }
            
            # Make the API call
            result = tonder_api.process_payment(payment_data)
            
            # A successful initiation will have a status of 'authorized' or 'pending'.
            # A 'declined' status is a failure for this attempt.
            if result.get("status") in ["authorized", "pending"]:
                print(f"Payment successfully initiated with {method}. Transaction ID: {result['id']}")
                return result
            else:
                # Handle declines or other failures before trying the next method
                print(f"Payment with {method} failed with status: {result.get('status')}")
                # In a real application, you might log the specific error message
                
        except Exception as e:
            # This handles API call failures (e.g., network errors, 500s)
            print(f"API call for payment method {method} failed: {e}")
            continue
    
    # If the loop completes without returning, all methods have failed.
    raise Exception("All payment methods failed for this transaction.")
```

## Example Usage

Here's how to use the fallback function in your application:

```python
# --- Example Usage ---
customer = {"name": "Test Fallback", "email": "fallback@example.com"}
try:
    successful_transaction = process_payment_with_fallback(customer, 250.00, "CARD")
    # Now handle the successful transaction (e.g., redirect for 3DS, show OXXO voucher)
except Exception as e:
    print(e)
```

## Next Steps

- Review individual [payment method guides](/direct-integration/payment-methods/payment-methods-overview) to understand each method's specific requirements
- Set up [webhooks](/direct-integration/webhooks/how-webhooks-works) to handle asynchronous payment status updates  
- Implement [error handling](/direct-integration/http-response-codes) to gracefully manage payment failures
- Test different scenarios using [testing data](/direct-integration/testing-data) to validate your fallback logic
